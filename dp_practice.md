## 🎯 DP 기본 드릴 문제집 (세트 1)

# DP 문제의 원본은 Baekjoon https://www.acmicpc.net/ 에 있습니다.
---

### ✅ 문제 1. 피보나치 수열 (Bottom-Up)

**설명**
N번째 피보나치 수를 계산하는 문제입니다. 피보나치 수열은 F(0) = 0, F(1) = 1로 시작하며, 이후의 수는 이전 두 수의 합입니다 (F(n) = F(n-1) + F(n-2)). N은 첫 줄에 주어집니다. N은 0 이상 90 이하의 정수입니다.

**입력 예시**
```
6
```

**출력 예시**
```
8
```

**풀이 코드**
```python
n = int(input())
dp = [0] * (n + 2) # n=0일 때 dp[0], n=1일 때 dp[1]까지 필요. n+1로 하면 n=0일때 index out of range. 넉넉히 n+2.
if n >= 0:
    dp[0] = 0
if n >= 1:
    dp[1] = 1

for i in range(2, n + 1):
    dp[i] = dp[i-1] + dp[i-2]

print(dp[n])
```

**풀이에 대한 설명**
`dp` 리스트를 생성하여 각 인덱스에 해당하는 피보나치 수를 저장합니다. `dp[i]`는 i번째 피보나치 수를 의미합니다. 반복문을 통해 `dp[i] = dp[i-1] + dp[i-2]` 점화식을 이용하여 바닥부터 값을 채워나가는 Bottom-Up 방식입니다. N이 0이나 1일 경우를 고려하여 초기값을 설정합니다.

---

### ✅ 문제 2. 피보나치 수열 (Top-Down - Memoization)

**설명**
N번째 피보나치 수를 계산하는 문제입니다. 이번에는 Top-Down (재귀 + 메모이제이션) 방식으로 해결합니다. N은 첫 줄에 주어집니다. N은 0 이상 90 이하의 정수입니다.

**입력 예시**
```
7
```

**출력 예시**
```
13
```

**풀이 코드**
```python
n = int(input())
memo = [-1] * (n + 2) # 계산된 값을 저장할 리스트, -1은 아직 계산되지 않음을 의미

def fibonacci(k):
    if memo[k] != -1:
        return memo[k]
    if k == 0:
        memo[k] = 0
        return 0
    if k == 1:
        memo[k] = 1
        return 1
    memo[k] = fibonacci(k-1) + fibonacci(k-2)
    return memo[k]

print(fibonacci(n))
```

**풀이에 대한 설명**
재귀 함수 `fibonacci(k)`는 k번째 피보나치 수를 반환합니다. `memo` 리스트를 사용하여 이미 계산된 값은 다시 계산하지 않고 즉시 반환합니다 (메모이제이션). 만약 `memo[k]`가 -1이면 아직 계산되지 않은 것이므로, 재귀 호출을 통해 값을 계산하고 `memo[k]`에 저장합니다.

---

### ✅ 문제 3. 1로 만들기 (기본 연산)

**설명**
정수 X가 주어졌을 때, 다음 세 가지 연산을 사용해서 1을 만들려고 합니다.
1. X가 3으로 나누어 떨어지면, 3으로 나눈다.
2. X가 2로 나누어 떨어지면, 2로 나눈다.
3. 1을 뺀다.
세 연산을 적절히 사용해서 1을 만드는데 필요한 연산 횟수의 최솟값을 출력하세요. X는 첫 줄에 주어지며, 1 이상 1,000,000 이하의 정수입니다.

**입력 예시**
```
10
```

**출력 예시**
```
3
```

**풀이 코드**
```python
x = int(input())
dp = [0] * (x + 1) # dp[i]는 i를 1로 만드는데 필요한 최소 연산 횟수

for i in range(2, x + 1):
    # 1을 빼는 경우
    dp[i] = dp[i-1] + 1
    # 2로 나누어 떨어지는 경우
    if i % 2 == 0:
        dp[i] = min(dp[i], dp[i//2] + 1)
    # 3으로 나누어 떨어지는 경우
    if i % 3 == 0:
        dp[i] = min(dp[i], dp[i//3] + 1)

print(dp[x])
```

**풀이에 대한 설명**
`dp[i]`는 숫자 `i`를 1로 만드는 데 필요한 최소 연산 횟수를 저장합니다. Bottom-Up 방식으로 `dp` 테이블을 채웁니다. `dp[i]`를 계산할 때, `dp[i-1]` (1을 빼는 연산), `dp[i//2]` (2로 나누는 연산, `i`가 2의 배수일 때), `dp[i//3]` (3으로 나누는 연산, `i`가 3의 배수일 때) 각각의 경우에 1을 더한 값들 중 최솟값을 선택합니다.

---

### ✅ 문제 4. 2 x N 타일 채우기

**설명**
2 x N 크기의 직사각형을 2 x 1 크기의 타일로 채우는 방법의 수를 구하는 문제입니다. N은 첫 줄에 주어지며, 1 이상 1,000 이하의 정수입니다. 방법의 수는 매우 커질 수 있으므로, 10007로 나눈 나머지를 출력합니다.

**입력 예시**
```
3
```

**출력 예시**
```
3
```

**풀이 코드**
```python
n = int(input())
dp = [0] * (n + 2) # dp[i]는 2xi 크기의 직사각형을 채우는 방법의 수
MOD = 10007

if n >= 1:
    dp[1] = 1
if n >= 2:
    dp[2] = 2

for i in range(3, n + 1):
    dp[i] = (dp[i-1] + dp[i-2]) % MOD

print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 2 x `i` 크기의 직사각형을 2 x 1 타일로 채우는 방법의 수를 나타냅니다.
- `i`번째 열을 채울 때, 세로 타일 하나 (2x1)를 사용하면 나머지 2 x (`i-1`)을 채우는 `dp[i-1]`가지 경우가 있습니다.
- `i`번째 열까지 채울 때, 가로 타일 두 개 (1x2 두 개)를 사용하면 나머지 2 x (`i-2`)를 채우는 `dp[i-2]`가지 경우가 있습니다.
따라서 점화식은 `dp[i] = dp[i-1] + dp[i-2]`가 됩니다. 초기값은 `dp[1]=1`, `dp[2]=2` 입니다. (2x2는 세로 두 개 또는 가로 두 개)

---

### ✅ 문제 5. 계단 오르기 (1칸 또는 2칸)

**설명**
N개의 계단이 있습니다. 한 번에 1칸 또는 2칸씩 오를 수 있을 때, 계단의 정상까지 오르는 방법의 총 경우의 수를 구하는 문제입니다. N은 첫 줄에 주어지며, 1 이상 45 이하의 정수입니다.

**입력 예시**
```
4
```

**출력 예시**
```
5
```

**풀이 코드**
```python
n = int(input())
dp = [0] * (n + 2) # dp[i]는 i번째 계단까지 오르는 방법의 수

dp[0] = 1 # 시작점 (0번 계단)에 도달하는 방법은 1가지로 가정 (아무것도 안 오름)
if n >= 1:
    dp[1] = 1 # 1번 계단: 1칸
if n >= 2:
    dp[2] = 2 # 2번 계단: 1칸+1칸, 2칸

for i in range(3, n + 1):
    dp[i] = dp[i-1] + dp[i-2]

print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 `i`번째 계단까지 오르는 방법의 수를 나타냅니다.
`i`번째 계단에 도달하기 위해서는:
1.  `i-1`번째 계단에서 1칸을 올라오는 경우 (`dp[i-1]` 가지)
2.  `i-2`번째 계단에서 2칸을 올라오는 경우 (`dp[i-2]` 가지)
두 가지 경우가 있습니다. 따라서 점화식은 `dp[i] = dp[i-1] + dp[i-2]`입니다.
`dp[0]`을 1로 설정하면 `dp[2] = dp[1] + dp[0]` = 1 + 1 = 2 와 같이 점화식이 자연스럽게 연결됩니다.
또는, `dp[1]=1`, `dp[2]=2`로 초기화하고 반복문을 3부터 시작해도 됩니다.

---

### ✅ 문제 6. 1차원 배열의 구간 합 (Prefix Sum)

**설명**
N개의 정수로 이루어진 수열이 주어집니다. 이 수열의 첫 번째 원소부터 i번째 원소까지의 합을 미리 계산하여, 특정 구간의 합을 빠르게 구하려고 합니다. 첫 줄에는 수열의 크기 N이 주어지고, 둘째 줄에는 N개의 정수가 공백으로 구분되어 주어집니다. 셋째 줄에는 M이 주어지고, 넷째 줄부터 M개의 줄에 걸쳐 각 줄마다 구간 시작 인덱스 `s`와 끝 인덱스 `e`가 주어집니다 (인덱스는 1부터 시작). 각 구간의 합을 출력하세요.

**입력 예시**
```
5
10 20 30 40 50
3
1 3
2 4
1 5
```

**출력 예시**
```
60
90
150
```

**풀이 코드**
```python
n = int(input())
numbers = list(map(int, input().split()))
m = int(input())

prefix_sum = [0] * (n + 1) # prefix_sum[i]는 numbers[0]부터 numbers[i-1]까지의 합
for i in range(n):
    prefix_sum[i+1] = prefix_sum[i] + numbers[i]

for _ in range(m):
    s, e = map(int, input().split())
    # s부터 e까지의 합은 (1부터 e까지의 합) - (1부터 s-1까지의 합)
    print(prefix_sum[e] - prefix_sum[s-1])
```

**풀이에 대한 설명**
`prefix_sum[i]`는 원본 배열의 첫 번째 원소부터 `i`번째 원소까지의 누적 합을 저장합니다 (이 코드에서는 `numbers`의 인덱스를 0부터 시작했으므로 `prefix_sum[i]`는 `numbers[0]...numbers[i-1]`의 합).
구간 `[s, e]` (1-based index)의 합은 `prefix_sum[e] - prefix_sum[s-1]`로 O(1) 시간에 계산할 수 있습니다.
`prefix_sum[0]`은 0으로 초기화하여 계산을 용이하게 합니다.

---

### ✅ 문제 7. 최대 증가 부분 수열 (LIS) - 길이

**설명**
수열 A가 주어졌을 때, 가장 긴 증가하는 부분 수열(LIS, Longest Increasing Subsequence)의 길이를 구하는 프로그램을 작성하세요.
첫 줄에는 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루는 N개의 정수가 공백으로 구분되어 주어집니다. N은 1 이상 1,000 이하, 수열의 각 원소는 1 이상 1,000 이하의 정수입니다.

**입력 예시**
```
6
10 20 10 30 20 50
```

**출력 예시**
```
4
```

**풀이 코드**
```python
n = int(input())
a = list(map(int, input().split()))

dp = [1] * n # dp[i]는 a[i]를 마지막 원소로 하는 LIS의 길이

for i in range(n):
    for j in range(i):
        if a[i] > a[j]:
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp) if dp else 0)
```

**풀이에 대한 설명**
`dp[i]`는 `a[i]`를 마지막 원소로 가지는 가장 긴 증가 부분 수열의 길이를 저장합니다.
각 `a[i]`에 대해, 그 이전의 원소 `a[j]` (`j < i`) 중에서 `a[j] < a[i]`인 경우들을 찾습니다.
이러한 `a[j]`를 마지막으로 하는 LIS의 길이는 `dp[j]`이므로, `a[i]`를 그 뒤에 붙이면 `dp[j] + 1` 길이의 증가 부분 수열을 만들 수 있습니다.
`dp[i]`는 이러한 `dp[j] + 1` 값들 중 최댓값으로 갱신됩니다. 초기값은 모든 `dp[i]`가 1 (자기 자신만 포함하는 경우)입니다.
최종 결과는 `dp` 배열의 최댓값입니다. (N=0일 경우 빈 리스트 max 오류 방지)

---

### ✅ 문제 8. 가장 긴 감소하는 부분 수열 (LDS) - 길이

**설명**
수열 A가 주어졌을 때, 가장 긴 감소하는 부분 수열(LDS, Longest Decreasing Subsequence)의 길이를 구하는 프로그램을 작성하세요.
첫 줄에는 수열 A의 크기 N이 주어지고, 둘째 줄에는 수열 A를 이루는 N개의 정수가 공백으로 구분되어 주어집니다. N은 1 이상 1,000 이하, 수열의 각 원소는 1 이상 1,000 이하의 정수입니다.

**입력 예시**
```
6
50 20 40 10 30 5
```

**출력 예시**
```
4
```

**풀이 코드**
```python
n = int(input())
a = list(map(int, input().split()))

dp = [1] * n # dp[i]는 a[i]를 마지막 원소로 하는 LDS의 길이

for i in range(n):
    for j in range(i):
        if a[i] < a[j]: # LDS 조건
            dp[i] = max(dp[i], dp[j] + 1)

print(max(dp) if dp else 0)
```

**풀이에 대한 설명**
`dp[i]`는 `a[i]`를 마지막 원소로 가지는 가장 긴 감소 부분 수열의 길이를 저장합니다.
LIS와 유사하게, 각 `a[i]`에 대해 그 이전의 원소 `a[j]` (`j < i`) 중에서 `a[j] > a[i]`인 경우들을 찾습니다.
이러한 `a[j]`를 마지막으로 하는 LDS의 길이는 `dp[j]`이므로, `a[i]`를 그 뒤에 붙이면 `dp[j] + 1` 길이의 감소 부분 수열을 만들 수 있습니다.
`dp[i]`는 이러한 `dp[j] + 1` 값들 중 최댓값으로 갱신됩니다. 초기값은 모든 `dp[i]`가 1입니다.
최종 결과는 `dp` 배열의 최댓값입니다.

---

### ✅ 문제 9. 쉬운 동전 교환 (경우의 수)

**설명**
주어진 동전들을 사용하여 특정 금액 K를 만드는 경우의 수를 구하는 문제입니다. 사용 가능한 동전의 종류는 첫 줄에 N으로 주어지고, 목표 금액 K가 공백으로 구분되어 주어집니다. 둘째 줄부터 N개의 줄에 걸쳐 각 동전의 가치가 주어집니다. 각 동전은 무한정 사용할 수 있습니다. (N은 1 이상 100 이하, K는 1 이상 10,000 이하, 동전 가치는 1 이상 100,000 이하)

**입력 예시**
```
3 10
1
2
5
```

**출력 예시**
```
10
```

**풀이 코드**
```python
n, k = map(int, input().split())
coins = []
for _ in range(n):
    coins.append(int(input()))

dp = [0] * (k + 1) # dp[i]는 i원을 만드는 경우의 수
dp[0] = 1 # 0원을 만드는 경우는 아무 동전도 사용하지 않는 1가지 경우

for coin in coins:
    for i in range(coin, k + 1):
        dp[i] += dp[i - coin]

print(dp[k])
```

**풀이에 대한 설명**
`dp[i]`는 금액 `i`를 만드는 경우의 수를 저장합니다. `dp[0]`은 1로 초기화합니다(0원을 만드는 방법은 아무것도 선택하지 않는 한 가지).
각 동전 `coin`에 대해, `dp` 테이블을 순회하면서 `dp[j]` (현재 금액 `j`)를 업데이트합니다.
`dp[j]`는 `dp[j - coin]` (현재 동전을 사용하기 전의 금액을 만드는 경우의 수)을 더함으로써 갱신됩니다. 즉, `(j - coin)`원을 만드는 경우의 수에 현재 동전 `coin`을 추가하는 것입니다.
동전의 순서대로 반복하고, 각 동전에 대해 금액을 작은 것부터 큰 것 순으로 업데이트해야 중복 계산 없이 올바른 경우의 수를 구할 수 있습니다.

---

### ✅ 문제 10. 배낭 채우기 (0/1 Knapsack - 기본 가치)

**설명**
N개의 물건이 있고, 각 물건은 무게 `w`와 가치 `v`를 가집니다. 최대 W만큼의 무게를 담을 수 있는 배낭에 물건들을 담아 가치의 합이 최대가 되도록 하려고 합니다. 각 물건은 하나씩만 있습니다 (쪼갤 수 없음).
첫 줄에는 물건의 수 N과 배낭의 최대 무게 W가 주어집니다. 다음 N개의 줄에는 각 물건의 무게 `w_i`와 가치 `v_i`가 주어집니다.
(N은 1 이상 100 이하, W는 1 이상 100,000 이하, w_i, v_i는 1 이상 1,000 이하)

**입력 예시**
```
4 7
6 13
4 8
3 6
5 12
```

**출력 예시**
```
14
```

**풀이 코드**
```python
n, capacity = map(int, input().split())
items = []
for _ in range(n):
    items.append(list(map(int, input().split()))) # [무게, 가치]

# dp[j]는 무게 한도가 j일 때의 최대 가치
dp = [0] * (capacity + 1)

for weight, value in items:
    # 현재 물건을 고려할 때, 배낭의 용량을 뒤에서부터 확인
    # 앞에서부터 하면 하나의 물건이 여러 번 선택될 수 있음 (dp[j-weight]가 이미 현재 물건을 포함한 상태일 수 있기 때문)
    for j in range(capacity, weight - 1, -1):
        dp[j] = max(dp[j], dp[j - weight] + value)

print(dp[capacity])
```

**풀이에 대한 설명**
`dp[j]`는 배낭의 용량이 `j`일 때 담을 수 있는 물건들의 최대 가치를 의미합니다.
각 물건 `(weight, value)`에 대해서, 배낭의 용량을 `capacity`부터 `weight`까지 역순으로 순회합니다.
역순으로 순회하는 이유는 각 물건을 한 번만 사용하기 위함입니다 (0/1 Knapsack).
만약 순방향으로 순회한다면, `dp[j - weight]`를 계산할 때 이미 현재 물건이 포함된 상태의 값을 참조할 수 있어, 같은 물건이 여러 번 선택되는 문제가 발생할 수 있습니다.
`dp[j]`는 다음 두 가지 경우 중 더 큰 값으로 업데이트됩니다:
1.  현재 물건을 담지 않는 경우: `dp[j]` (이전 물건들까지만 고려했을 때의 최대 가치)
2.  현재 물건을 담는 경우: `dp[j - weight] + value` (현재 물건의 무게만큼을 제외한 용량에서의 최대 가치 + 현재 물건의 가치)

---

### ✅ 문제 11. 정수 삼각형

**설명**
크기가 N인 정수 삼각형이 주어집니다. 맨 위층부터 시작하여 아래에 있는 수 중 하나를 선택하여 아래층으로 내려올 때, 이제까지 선택된 수의 합이 최대가 되는 경로를 구하려고 합니다. 단, 대각선 왼쪽 또는 대각선 오른쪽으로만 이동 가능합니다.
첫 줄에는 삼각형의 크기 N (1 <= N <= 500)이 주어지고, 둘째 줄부터 N+1번째 줄까지 정수 삼각형의 정보가 주어집니다.

**입력 예시**
```
5
7
3 8
8 1 0
2 7 4 4
4 5 2 6 5
```

**출력 예시**
```
30
```

**풀이 코드**
```python
n = int(input())
triangle = []
for _ in range(n):
    triangle.append(list(map(int, input().split())))

# dp 테이블을 입력 삼각형과 같은 크기로 만들고 초기화 (또는 입력 자체를 dp로 활용)
dp = [row[:] for row in triangle] # Deep copy

for i in range(1, n):
    for j in range(len(triangle[i])):
        if j == 0: # 왼쪽 가장자리
            dp[i][j] = dp[i-1][j] + triangle[i][j]
        elif j == len(triangle[i]) - 1: # 오른쪽 가장자리
            dp[i][j] = dp[i-1][j-1] + triangle[i][j]
        else: # 중간
            dp[i][j] = max(dp[i-1][j-1], dp[i-1][j]) + triangle[i][j]

print(max(dp[n-1]) if n > 0 else 0)
```

**풀이에 대한 설명**
`dp[i][j]`는 `i`번째 행, `j`번째 열의 숫자를 선택했을 때, 맨 위층부터 해당 위치까지 내려오는 경로의 숫자 합의 최댓값을 저장합니다.
-   `i`번째 행의 `j`번째 숫자에 도달하기 위해서는 `i-1`번째 행의 `j-1`번째 숫자 또는 `j`번째 숫자에서 내려와야 합니다.
-   점화식:
    -   `dp[i][j] = triangle[i][j] + dp[i-1][j]` (왼쪽 위에서 오는 경우, `j=0`)
    -   `dp[i][j] = triangle[i][j] + dp[i-1][j-1]` (오른쪽 위에서 오는 경우, `j=len(triangle[i])-1`)
    -   `dp[i][j] = triangle[i][j] + max(dp[i-1][j-1], dp[i-1][j])` (그 외)
삼각형의 각 값을 `triangle[i][j]`로 읽어들이고, `dp` 테이블을 채워나갑니다. 마지막 행 `dp[n-1]`의 최댓값이 정답입니다.

---

### ✅ 문제 12. 편집 거리 (Levenshtein Distance) - 기본

**설명**
두 문자열 A와 B가 주어졌을 때, 문자열 A를 문자열 B로 바꾸는 데 필요한 최소 편집 연산(삽입, 삭제, 교체)의 횟수를 구하는 문제입니다.
첫째 줄과 둘째 줄에 각각 문자열 A와 B가 주어집니다. 문자열의 길이는 1 이상 100 이하입니다.

**입력 예시**
```
sunday
saturday
```

**출력 예시**
```
3
```

**풀이 코드**
```python
str1 = input()
str2 = input()
len1, len2 = len(str1), len(str2)

# dp[i][j]는 str1의 첫 i글자를 str2의 첫 j글자로 바꾸는 데 필요한 최소 편집 거리
dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]

for i in range(len1 + 1):
    dp[i][0] = i # str1의 i글자를 빈 문자열로 만들려면 i번 삭제
for j in range(len2 + 1):
    dp[0][j] = j # 빈 문자열을 str2의 j글자로 만들려면 j번 삽입

for i in range(1, len1 + 1):
    for j in range(1, len2 + 1):
        if str1[i-1] == str2[j-1]: # 문자가 같으면 이전 편집 거리 그대로
            dp[i][j] = dp[i-1][j-1]
        else: # 문자가 다르면 삽입, 삭제, 교체 중 최소 비용 선택
            dp[i][j] = 1 + min(dp[i-1][j],    # 삭제 (str1[i-1] 삭제)
                               dp[i][j-1],    # 삽입 (str2[j-1] 삽입)
                               dp[i-1][j-1])  # 교체 (str1[i-1]을 str2[j-1]로)

print(dp[len1][len2])
```

**풀이에 대한 설명**
`dp[i][j]`는 문자열 `str1`의 처음 `i`개 문자를 문자열 `str2`의 처음 `j`개 문자로 변경하는 데 필요한 최소 편집 횟수를 나타냅니다.
-   기저 사례: `dp[i][0] = i` (str1의 i개 문자를 모두 삭제), `dp[0][j] = j` (str2의 j개 문자를 모두 삽입).
-   점화식:
    -   만약 `str1[i-1] == str2[j-1]` (현재 비교하는 문자가 같으면), `dp[i][j] = dp[i-1][j-1]` (이전 문자까지의 편집 횟수와 동일).
    -   만약 `str1[i-1] != str2[j-1]` (문자가 다르면), `dp[i][j] = 1 + min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1])`.
        -   `dp[i-1][j]`: `str1`에서 `i`번째 문자 삭제.
        -   `dp[i][j-1]`: `str1`의 `i`번째 위치에 `str2`의 `j`번째 문자 삽입.
        -   `dp[i-1][j-1]`: `str1`의 `i`번째 문자를 `str2`의 `j`번째 문자로 교체.
최종 결과는 `dp[len(str1)][len(str2)]`입니다.

---

### ✅ 문제 13. 가장 긴 공통 부분 수열 (LCS) - 길이

**설명**
두 문자열이 주어졌을 때, 두 문자열 모두에 공통으로 존재하는 가장 긴 부분 수열(LCS, Longest Common Subsequence)의 길이를 구하는 문제입니다. 부분 수열은 원래 순서를 유지해야 합니다.
첫째 줄과 둘째 줄에 각각 문자열이 주어집니다. 문자열의 길이는 1 이상 100 이하입니다.

**입력 예시**
```
ACAYKP
CAPCAK
```

**출력 예시**
```
4
```

**풀이 코드**
```python
str1 = input()
str2 = input()
len1, len2 = len(str1), len(str2)

# dp[i][j]는 str1의 첫 i글자와 str2의 첫 j글자 사이의 LCS 길이
dp = [[0] * (len2 + 1) for _ in range(len1 + 1)]

for i in range(1, len1 + 1):
    for j in range(1, len2 + 1):
        if str1[i-1] == str2[j-1]: # 현재 문자가 같으면
            dp[i][j] = dp[i-1][j-1] + 1
        else: # 현재 문자가 다르면
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])

print(dp[len1][len2])
```

**풀이에 대한 설명**
`dp[i][j]`는 `str1`의 처음 `i`개 문자와 `str2`의 처음 `j`개 문자 사이의 가장 긴 공통 부분 수열(LCS)의 길이를 저장합니다.
-   점화식:
    -   만약 `str1[i-1] == str2[j-1]` (현재 비교하는 문자가 같으면), 이 문자는 LCS에 포함될 수 있으므로 `dp[i][j] = dp[i-1][j-1] + 1`.
    -   만약 `str1[i-1] != str2[j-1]` (문자가 다르면), 현재 문자는 동시에 LCS에 포함될 수 없으므로, 두 경우 중 더 긴 쪽을 선택합니다:
        -   `dp[i-1][j]`: `str1`의 `i-1`번째 문자를 제외하고 `str2`의 `j`번째 문자까지 고려한 LCS 길이.
        -   `dp[i][j-1]`: `str1`의 `i`번째 문자까지 고려하고 `str2`의 `j-1`번째 문자를 제외한 LCS 길이.
        -   따라서, `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`.
최종 결과는 `dp[len(str1)][len(str2)]`입니다.

---

### ✅ 문제 14. 계단 오르기 (특정 칸 피하기)

**설명**
N개의 계단이 있고, 한 번에 1칸 또는 2칸씩 오를 수 있습니다. 단, M개의 특정 계단은 밟을 수 없습니다. 계단의 정상(N번째 칸)까지 오르는 방법의 총 경우의 수를 구하는 문제입니다.
첫 줄에는 총 계단 수 N (1 <= N <= 45)과 밟을 수 없는 계단의 수 M (0 <= M <= N)이 주어집니다. 둘째 줄에는 밟을 수 없는 M개의 계단 번호가 오름차순으로 주어집니다 (계단 번호는 1부터 N까지). 경우의 수는 0일 수도 있습니다.

**입력 예시**
```
6 1
3
```

**출력 예시**
```
3
```

**풀이 코드**
```python
n, m = map(int, input().split())
forbidden_steps = set()
if m > 0:
    forbidden_steps = set(map(int, input().split()))

dp = [0] * (n + 1) # dp[i]는 i번째 계단까지 오르는 방법의 수

# 시작점은 밟을 수 있다고 가정 (0번 계단)
if 0 not in forbidden_steps: # 실제로는 0번 계단을 금지하는 경우는 없음
    dp[0] = 1

for i in range(1, n + 1):
    if i in forbidden_steps:
        dp[i] = 0 # 밟을 수 없는 계단은 경우의 수 0
        continue
    
    # i-1에서 오는 경우
    if i - 1 >= 0:
        dp[i] += dp[i-1]
    # i-2에서 오는 경우
    if i - 2 >= 0:
        dp[i] += dp[i-2]

print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 `i`번째 계단까지 오르는 방법의 수를 나타냅니다.
기본적인 계단 오르기 문제(문제 5)와 유사하지만, 밟을 수 없는 계단은 경우의 수를 0으로 처리합니다.
-   `dp[0] = 1`로 시작합니다 (0번째 계단, 즉 시작점에 도달하는 방법은 1가지).
-   각 `i`번째 계단에 대해:
    -   만약 `i`가 밟을 수 없는 계단(`forbidden_steps`에 포함)이면 `dp[i] = 0`.
    -   그렇지 않으면, `dp[i] = dp[i-1] + dp[i-2]` (단, `i-1`이나 `i-2`가 음수가 되지 않도록 주의).
정상인 N번째 계단까지 도달하는 방법의 수는 `dp[n]`입니다.

---

### ✅ 문제 15. 돌다리 건너기 (1, 2, 3칸 점프)

**설명**
N개의 돌로 이루어진 돌다리를 건너려고 합니다. 현재 위치에서 1칸, 2칸, 또는 3칸 앞의 돌로 점프할 수 있습니다. 돌다리의 시작점(0번 위치)에서 N번 돌까지 도달하는 방법의 총 경우의 수를 구하는 문제입니다. N은 첫 줄에 주어지며, 1 이상 20 이하의 정수입니다.

**입력 예시**
```
4
```

**출력 예시**
```
7
```

**풀이 코드**
```python
n = int(input())
dp = [0] * (n + 3) # dp[i]는 i번째 돌까지 오는 방법의 수 (넉넉하게 n+3)

dp[0] = 1 # 시작점

for i in range(1, n + 1):
    if i - 1 >= 0:
        dp[i] += dp[i-1]
    if i - 2 >= 0:
        dp[i] += dp[i-2]
    if i - 3 >= 0:
        dp[i] += dp[i-3]

print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 `i`번째 돌까지 도달하는 방법의 수를 저장합니다.
`i`번째 돌에 도달하기 위해서는 다음 세 가지 경우가 있습니다:
1.  `i-1`번째 돌에서 1칸 점프하여 오는 경우 (`dp[i-1]` 가지)
2.  `i-2`번째 돌에서 2칸 점프하여 오는 경우 (`dp[i-2]` 가지)
3.  `i-3`번째 돌에서 3칸 점프하여 오는 경우 (`dp[i-3]` 가지)
따라서 점화식은 `dp[i] = dp[i-1] + dp[i-2] + dp[i-3]`입니다.
`dp[0]`은 1로 설정하여 (시작점에 있는 방법 1가지), `dp[1]`, `dp[2]`, `dp[3]` 등이 올바르게 계산되도록 합니다.
예를 들어, `dp[1] = dp[0] = 1`, `dp[2] = dp[1] + dp[0] = 2`, `dp[3] = dp[2] + dp[1] + dp[0] = 2 + 1 + 1 = 4`.

---

### ✅ 문제 16. 연속합 (Maximum Subarray Sum)

**설명**
n개의 정수로 이루어진 임의의 수열이 주어집니다. 이 중 연속된 몇 개의 수를 선택해서 구할 수 있는 합 중 가장 큰 합을 구하려고 합니다. 단, 수는 한 개 이상 선택해야 합니다.
첫 줄에는 정수 n (1 <= n <= 100,000)이 주어지고, 둘째 줄에는 n개의 정수가 공백으로 구분되어 주어집니다. 각 정수는 -1,000 이상 1,000 이하입니다.

**입력 예시**
```
10
10 -4 3 1 5 6 -35 12 21 -1
```

**출력 예시**
```
33
```

**풀이 코드**
```python
n = int(input())
arr = list(map(int, input().split()))

dp = [0] * n
dp[0] = arr[0]

for i in range(1, n):
    # 현재 원소 arr[i]를 포함하는 연속 부분합은
    # (이전까지의 연속 부분합 dp[i-1]에 arr[i]를 더한 값) 과 (arr[i]부터 새로 시작하는 값) 중 큰 값
    dp[i] = max(arr[i], dp[i-1] + arr[i])

print(max(dp))
```

**풀이에 대한 설명**
`dp[i]`는 `arr[i]`를 반드시 포함하는(즉, `arr[i]`로 끝나는) 연속된 부분 수열의 합 중 최댓값을 의미합니다.
-   `dp[0]`은 `arr[0]`입니다 (첫 번째 원소로 끝나는 최대 연속합은 자기 자신).
-   `i > 0`일 때, `dp[i]`는 다음 두 가지 경우 중 더 큰 값입니다:
    1.  `arr[i]`만으로 새로운 연속 부분 수열을 시작하는 경우 (`arr[i]`).
    2.  `arr[i-1]`로 끝나는 최대 연속 부분 수열에 `arr[i]`를 이어 붙이는 경우 (`dp[i-1] + arr[i]`).
-   점화식: `dp[i] = max(arr[i], dp[i-1] + arr[i])`.
수열 전체에서 가장 큰 연속합은 `dp` 배열의 모든 값들 중 최댓값입니다. 이는 카데인 알고리즘(Kadane's Algorithm)의 핵심 아이디어입니다.

---

### ✅ 문제 17. 파도반 수열 (변형 피보나치)

**설명**
파도반 수열 P(N)은 아래와 같이 정의됩니다.
P(1) = 1, P(2) = 1, P(3) = 1, P(4) = 2, P(5) = 2
N > 5일 때, P(N) = P(N-1) + P(N-5)
N이 주어졌을 때, P(N)을 구하는 문제입니다. N은 첫 줄에 주어지며, 1 이상 100 이하의 정수입니다.

**입력 예시**
```
6
```

**출력 예시**
```
3
```

**풀이 코드**
```python
n = int(input())
dp = [0] * (max(n + 1, 6)) # 최소 P(5)까지 필요하므로, n+1과 6 중 큰 값으로 dp 배열 크기 설정

dp[1] = 1
dp[2] = 1
dp[3] = 1
dp[4] = 2
dp[5] = 2

for i in range(6, n + 1):
    dp[i] = dp[i-1] + dp[i-5]

print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 파도반 수열의 `i`번째 값 P(i)를 저장합니다.
문제에서 주어진 초기값 P(1)부터 P(5)까지를 `dp` 배열에 설정합니다.
- `dp[1] = 1`
- `dp[2] = 1`
- `dp[3] = 1`
- `dp[4] = 2`
- `dp[5] = 2`
N이 6 이상인 경우, 점화식 `dp[i] = dp[i-1] + dp[i-5]`를 이용하여 `dp` 값을 순차적으로 계산합니다.
최종적으로 `dp[n]`이 구하고자 하는 P(N) 값입니다. 입력 N이 5 이하일 경우를 대비하여 `dp` 배열 크기를 `max(n+1, 6)`으로 하는 것이 안전합니다.

---

### ✅ 문제 18. 제곱수의 합 (최소 항의 개수)

**설명**
주어진 자연수 N을 제곱수들의 합으로 표현할 때, 필요한 최소 항의 개수를 구하는 문제입니다. 예를 들어 11은 <span class="math-inline">3^2 \+ 1^2 \+ 1^2</span> (3개 항) 또는 <span class="math-inline">2^2 \+ 2^2 \+ 1^2 \+ 1^2 \+ 1^2</span> (5개 항) 등으로 표현 가능하며, 이때 최소 항의 개수는 3입니다.
N은 첫 줄에 주어지며, 1 이상 50,000 이하의 자연수입니다.

**입력 예시**
```
11
```

**출력 예시**
```
3
```

**풀이 코드**
```python
n = int(input())
dp = [float('inf')] * (n + 1) # dp[i]는 i를 제곱수의 합으로 나타낼 때 필요한 최소 항의 개수
dp[0] = 0 # 0을 만드는 데 필요한 항의 개수는 0

for i in range(1, n + 1):
    j = 1
    while j * j <= i:
        dp[i] = min(dp[i], dp[i - j*j] + 1)
        j += 1

print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 자연수 `i`를 제곱수들의 합으로 표현할 때 필요한 최소 항의 개수를 저장합니다.
`dp[0]`은 0으로 초기화합니다 (0을 만드는 데 필요한 항은 없음).
모든 `dp[i]`는 초기에 매우 큰 값(무한대)으로 설정합니다.
1부터 N까지 각 숫자 `i`에 대해, `i`보다 작거나 같은 모든 제곱수 `j*j`를 고려합니다.
만약 `i`를 `(i - j*j) + j*j`로 표현한다면, `i`를 만드는 데 필요한 항의 개수는 `dp[i - j*j] + 1`이 됩니다.
`dp[i]`는 이러한 `dp[i - j*j] + 1` 값들 중 최솟값으로 갱신됩니다.
즉, `dp[i] = min(dp[i], dp[i - k^2] + 1)` (단, <span class="math-inline">k^2 \\le i</span>)

---

### ✅ 문제 19. 가장 긴 바이토닉 부분 수열

**설명**
수열 S가 주어졌을 때, 그 수열의 부분 수열 중에서 바이토닉(bitonic) 수열이면서 가장 긴 것의 길이를 구하는 문제입니다. 바이토닉 수열이란, 어떤 지점까지는 증가하고 그 이후부터는 감소하는 수열을 말합니다. (단, 계속 증가하거나 계속 감소하는 것도 바이토닉 수열로 간주합니다.)
첫 줄에는 수열의 크기 N (1 <= N <= 1,000)이 주어지고, 둘째 줄에는 수열 S를 이루는 N개의 정수가 공백으로 구분되어 주어집니다. (각 원소는 1 이상 1,000 이하)

**입력 예시**
```
10
1 5 2 1 4 3 2 5 1 2
```

**출력 예시**
```
7
```

**풀이 코드**
```python
n = int(input())
s = list(map(int, input().split()))

# dp_inc[i]: s[i]를 마지막으로 하는 가장 긴 증가하는 부분 수열의 길이
dp_inc = [1] * n
for i in range(n):
    for j in range(i):
        if s[i] > s[j]:
            dp_inc[i] = max(dp_inc[i], dp_inc[j] + 1)

# dp_dec[i]: s[i]를 시작으로 하는 가장 긴 감소하는 부분 수열의 길이
# (배열을 뒤집어서 LIS를 구하는 것과 동일)
dp_dec = [1] * n
s_reversed = s[::-1]
temp_dp_dec = [1] * n # 뒤집은 배열에 대한 LIS
for i in range(n):
    for j in range(i):
        if s_reversed[i] > s_reversed[j]:
            temp_dp_dec[i] = max(temp_dp_dec[i], temp_dp_dec[j] + 1)
dp_dec = temp_dp_dec[::-1] # 원래 순서로 다시 뒤집기

max_len = 0
if n == 0:
    print(0)
else:
    for i in range(n):
        # s[i]가 바이토닉 수열의 "peak"인 경우
        # dp_inc[i] + dp_dec[i] - 1 (s[i]가 중복 계산되므로 1 빼줌)
        max_len = max(max_len, dp_inc[i] + dp_dec[i] - 1)
    print(max_len)

```

**풀이에 대한 설명**
가장 긴 바이토닉 부분 수열의 길이를 찾기 위해, 각 원소 `s[i]`를 "봉우리(peak)"로 간주하고 다음 두 가지를 계산합니다.
1.  `dp_inc[i]`: `s[i]`에서 끝나는 가장 긴 증가 부분 수열(LIS)의 길이.
2.  `dp_dec[i]`: `s[i]`에서 시작하는 가장 긴 감소 부분 수열(LDS)의 길이. LDS는 원본 수열을 뒤집은 후 LIS를 구하고, 그 결과를 다시 뒤집어서 얻을 수 있습니다.

각 `i`에 대해 `dp_inc[i] + dp_dec[i] - 1`이 `s[i]`를 봉우리로 하는 바이토닉 부분 수열의 길이가 됩니다 (`s[i]`가 LIS와 LDS 양쪽에 포함되므로 중복으로 계산된 1을 빼줍니다).
이 값들 중 최댓값이 가장 긴 바이토닉 부분 수열의 길이입니다. 만약 수열이 비어있으면 0을 출력합니다.

---

### ✅ 문제 20. 스티커 모으기 (2xN)

**설명**
2행 N열로 배치된 스티커들이 있습니다. 스티커 한 장을 떼면, 그 스티커와 변을 공유하는 스티커들은 사용할 수 없게 됩니다(상, 하, 좌, 우). 뗄 수 있는 스티커들의 점수 합의 최댓값을 구하는 문제입니다.
첫 줄에는 테스트 케이스의 개수 T가 주어집니다. 각 테스트 케이스의 첫 줄에는 N (1 <= N <= 100,000)이 주어지고, 다음 두 줄에 걸쳐 각 행의 스티커 점수가 N개씩 주어집니다. (점수는 0 이상 100 이하)

**입력 예시**
```
1
5
50 10 100 20 40
30 50 70 10 60
```

**출력 예시**
```
260
```

**풀이 코드**
```python
def solve():
    n = int(input())
    stickers = []
    for _ in range(2):
        stickers.append(list(map(int, input().split())))

    if n == 0:
        print(0)
        return
    if n == 1:
        print(max(stickers[0][0], stickers[1][0]))
        return

    # dp[col][0]: col번째 열의 위쪽 스티커를 선택했을 때의 최대 점수
    # dp[col][1]: col번째 열의 아래쪽 스티커를 선택했을 때의 최대 점수
    dp = [[0] * n for _ in range(2)]

    dp[0][0] = stickers[0][0]
    dp[1][0] = stickers[1][0]

    if n > 1:
        dp[0][1] = stickers[0][1] + dp[1][0]
        dp[1][1] = stickers[1][1] + dp[0][0]

    for i in range(2, n):
        # i번째 열의 위쪽 스티커 선택
        # -> (i-1)번째 열의 아래쪽 스티커 선택 or (i-2)번째 열의 (위 or 아래) 스티커 선택
        dp[0][i] = stickers[0][i] + max(dp[1][i-1], dp[0][i-2] if i-2 >= 0 else 0, dp[1][i-2] if i-2 >= 0 else 0)
        
        # i번째 열의 아래쪽 스티커 선택
        # -> (i-1)번째 열의 위쪽 스티커 선택 or (i-2)번째 열의 (위 or 아래) 스티커 선택
        dp[1][i] = stickers[1][i] + max(dp[0][i-1], dp[0][i-2] if i-2 >= 0 else 0, dp[1][i-2] if i-2 >= 0 else 0)
        
    print(max(dp[0][n-1], dp[1][n-1]))


T = int(input())
for _ in range(T):
    solve()
```

**풀이에 대한 설명**
`dp[0][i]`는 `i`번째 열에서 위쪽 스티커를 선택했을 때, 0부터 `i`열까지 얻을 수 있는 최대 점수를 의미합니다.
`dp[1][i]`는 `i`번째 열에서 아래쪽 스티커를 선택했을 때, 0부터 `i`열까지 얻을 수 있는 최대 점수를 의미합니다.

점화식:
- `dp[0][i]` (i열 위쪽 선택): `stickers[0][i]` + `max(`
    - `dp[1][i-1]` (i-1열 아래쪽 선택),
    - `dp[0][i-2]` (i-2열 위쪽 선택, i열 위쪽과 대각선),
    - `dp[1][i-2]` (i-2열 아래쪽 선택, i열 위쪽과 대각선)
  `)`
- `dp[1][i]` (i열 아래쪽 선택): `stickers[1][i]` + `max(`
    - `dp[0][i-1]` (i-1열 위쪽 선택),
    - `dp[0][i-2]` (i-2열 위쪽 선택, i열 아래쪽과 대각선),
    - `dp[1][i-2]` (i-2열 아래쪽 선택, i열 아래쪽과 대각선)
  `)`

기저 사례:
- `dp[0][0] = stickers[0][0]`
- `dp[1][0] = stickers[1][0]`
- `n > 1`일 때:
    - `dp[0][1] = stickers[0][1] + dp[1][0]`
    - `dp[1][1] = stickers[1][1] + dp[0][0]`

`i-2`가 음수가 되지 않도록 주의해야 합니다. 최종 결과는 `max(dp[0][n-1], dp[1][n-1])`입니다.
이 문제는 테스트 케이스 T가 주어지므로, 각 케이스마다 solve 함수를 호출하여 처리합니다.


---

### ✅ 문제 21. 2 x N 타일 채우기 2

**설명**
2 x N 크기의 직사각형을 1x2, 2x1, 그리고 2x2 타일로 채우는 방법의 수를 구하는 문제입니다. N은 첫 줄에 주어지며, 1 이상 30 이하의 정수입니다. 방법의 수는 10007로 나눈 나머지를 출력합니다.

**입력 예시**
```
3
```

**출력 예시**
```
5
```

**풀이 코드**
```python
n = int(input())
dp = [0] * (max(n + 1, 3)) # n=0, n=1, n=2 에 대한 처리 필요
MOD = 10007

dp[0] = 1 # 아무것도 안 채우는 방법 1가지 (점화식 구성을 위해)
if n >= 1:
    dp[1] = 1   # 2x1 타일 1개
if n >= 2:
    dp[2] = 3   # (2x1 2개), (1x2 2개), (2x2 1개)

for i in range(3, n + 1):
    # dp[i-1] : i-1까지 채우고 2x1 타일 하나 세로로 추가
    # dp[i-2] * 2 : i-2까지 채우고 1x2 타일 두 개 가로로 추가 또는 2x2 타일 하나 추가
    dp[i] = (dp[i-1] + 2 * dp[i-2]) % MOD

print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 2 x `i` 크기의 직사각형을 주어진 타일로 채우는 방법의 수를 나타냅니다.
-   `i`번째 열까지 채우는 경우:
    1.  `i-1`번째 열까지 채우고, `i`번째 열에 2x1 타일 1개를 세로로 놓는 경우: `dp[i-1]` 가지.
    2.  `i-2`번째 열까지 채우고, `i-1`부터 `i`번째 열까지 1x2 타일 2개를 가로로 놓는 경우: `dp[i-2]` 가지.
    3.  `i-2`번째 열까지 채우고, `i-1`부터 `i`번째 열까지 2x2 타일 1개를 놓는 경우: `dp[i-2]` 가지.
-   점화식: `dp[i] = dp[i-1] + dp[i-2] + dp[i-2] = dp[i-1] + 2 * dp[i-2]`
-   기저 사례:
    -   `dp[0] = 1` (계산의 편의를 위해, 2x0을 채우는 방법은 1가지로 설정)
    -   `dp[1] = 1` (2x1 타일 하나)
    -   `dp[2] = 3` (세로 두 개, 가로 두 개, 2x2 하나)
점화식에 기저 사례를 대입하면 `dp[2] = dp[1] + 2*dp[0] = 1 + 2*1 = 3`으로 일치합니다.

---

### ✅ 문제 22. 가장 큰 정사각형 찾기

**설명**
0과 1로만 이루어진 2차원 배열(board)이 주어질 때, 1로만 이루어진 가장 큰 정사각형을 찾아 그 한 변의 길이를 반환하는 문제입니다.
첫 줄에는 배열의 행의 수 N과 열의 수 M이 주어집니다 (1 <= N, M <= 1,000). 다음 N개의 줄에는 배열의 각 행의 원소가 공백 없이 주어집니다.

**입력 예시**
```
4 4
0111
1111
1111
0010
```

**출력 예시**
```
3
```

**풀이 코드**
```python
n, m = map(int, input().split())
board = []
for _ in range(n):
    board.append(list(map(int, list(input()))))

# dp[i][j]는 (i,j)를 우측 하단 꼭짓점으로 하는 가장 큰 정사각형의 한 변의 길이
dp = [[0] * m for _ in range(n)]
max_side = 0

for i in range(n):
    for j in range(m):
        if board[i][j] == 1:
            if i == 0 or j == 0: # 첫 행 또는 첫 열인 경우
                dp[i][j] = 1
            else:
                dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1
            max_side = max(max_side, dp[i][j])

print(max_side)
```

**풀이에 대한 설명**
`dp[i][j]`는 입력 배열 `board`에서 `(i, j)` 위치를 오른쪽 아래 꼭짓점으로 하는, 1로만 이루어진 가장 큰 정사각형의 한 변의 길이를 저장합니다.
-   만약 `board[i][j]`가 0이면, `dp[i][j]`는 0입니다 (정사각형을 만들 수 없음).
-   만약 `board[i][j]`가 1이면:
    -   `i=0` 또는 `j=0` (첫 번째 행 또는 열)인 경우, `dp[i][j] = 1`.
    -   그 외의 경우, `dp[i][j] = min(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1`.
        이는 `(i,j)` 위치에서 왼쪽, 위쪽, 대각선 왼쪽 위의 세 위치가 모두 정사각형을 이룰 수 있어야 `(i,j)`를 포함하는 더 큰 정사각형을 이룰 수 있기 때문입니다.
배열을 모두 순회하면서 `dp[i][j]`의 최댓값을 찾으면 그것이 가장 큰 정사각형의 한 변의 길이가 됩니다.

---

### ✅ 문제 23. RGB거리

**설명**
N개의 집을 빨강, 초록, 파랑 중 하나의 색으로 칠하려고 합니다. 각 집을 특정 색으로 칠하는 비용이 주어져 있을 때, 아래 규칙을 만족하며 모든 집을 칠하는 최소 비용을 구하세요.
1.  1번 집의 색은 2번 집의 색과 같지 않아야 한다.
2.  N번 집의 색은 N-1번 집의 색과 같지 않아야 한다.
3.  i(2 ≤ i ≤ N-1)번 집의 색은 i-1번, i+1번 집의 색과 같지 않아야 한다.

첫 줄에는 집의 수 N (2 <= N <= 1,000)이 주어집니다. 둘째 줄부터 N개의 줄에 걸쳐 각 집을 빨강, 초록, 파랑으로 칠하는 비용이 순서대로 주어집니다.

**입력 예시**
```
3
26 40 83
49 60 57
13 89 99
```

**출력 예시**
```
96
```

**풀이 코드**
```python
n = int(input())
costs = []
for _ in range(n):
    costs.append(list(map(int, input().split()))) # R, G, B 비용

# dp[i][0]: i번째 집을 빨강으로 칠했을 때까지의 최소 비용
# dp[i][1]: i번째 집을 초록으로 칠했을 때까지의 최소 비용
# dp[i][2]: i번째 집을 파랑으로 칠했을 때까지의 최소 비용
dp = [[0] * 3 for _ in range(n)]

# 첫 번째 집 초기화
dp[0][0] = costs[0][0]
dp[0][1] = costs[0][1]
dp[0][2] = costs[0][2]

for i in range(1, n):
    # i번째 집을 빨강으로 칠하는 경우 -> i-1번째 집은 초록 또는 파랑
    dp[i][0] = costs[i][0] + min(dp[i-1][1], dp[i-1][2])
    # i번째 집을 초록으로 칠하는 경우 -> i-1번째 집은 빨강 또는 파랑
    dp[i][1] = costs[i][1] + min(dp[i-1][0], dp[i-1][2])
    # i번째 집을 파랑으로 칠하는 경우 -> i-1번째 집은 빨강 또는 초록
    dp[i][2] = costs[i][2] + min(dp[i-1][0], dp[i-1][1])

print(min(dp[n-1][0], dp[n-1][1], dp[n-1][2]))
```

**풀이에 대한 설명**
`dp[i][color_index]`는 `i`번째 집을 해당 `color_index`(0:빨강, 1:초록, 2:파랑)로 칠했을 때, 0번째 집부터 `i`번째 집까지 칠하는 데 드는 누적 최소 비용을 나타냅니다.
-   `dp[0][R]`, `dp[0][G]`, `dp[0][B]`는 첫 번째 집을 각 색으로 칠하는 비용으로 초기화합니다.
-   `i`번째 집을 특정 색으로 칠하는 최소 비용은, (`i`번째 집을 해당 색으로 칠하는 비용) + (`i-1`번째 집을 현재 색과 다른 두 색 중 하나로 칠했을 때의 최소 비용)입니다.
    -   `dp[i][R] = costs[i][R] + min(dp[i-1][G], dp[i-1][B])`
    -   `dp[i][G] = costs[i][G] + min(dp[i-1][R], dp[i-1][B])`
    -   `dp[i][B] = costs[i][B] + min(dp[i-1][R], dp[i-1][G])`
최종적으로 `dp[n-1]` (마지막 집)의 세 가지 색상에 대한 비용 중 최솟값이 정답입니다.

---

### ✅ 문제 24. 포도주 시식

**설명**
일렬로 놓인 N개의 포도주 잔이 있고, 각 잔에는 일정량의 포도주가 들어있습니다. 포도주를 마실 때 다음과 같은 규칙이 있습니다.
1.  포도주 잔을 선택하면 그 잔에 들어있는 포도주는 모두 마셔야 하고, 원래 위치에 다시 놓아야 한다.
2.  연속으로 놓여 있는 3잔을 모두 마실 수는 없다.
N개의 포도주 잔이 주어졌을 때 마실 수 있는 포도주의 최대 양을 구하세요. N은 1 이상 10,000 이하입니다.

**입력 예시**
```
6
6
10
13
9
8
1
```

**출력 예시**
```
33
```

**풀이 코드**
```python
n = int(input())
wines = [0] # 0번 인덱스는 사용 안함 (계산 편의)
for _ in range(n):
    wines.append(int(input()))

if n == 0:
    print(0)
elif n == 1:
    print(wines[1])
else:
    # dp[i]는 i번째 포도주까지 고려했을 때 마실 수 있는 최대 포도주 양
    dp = [0] * (n + 1)
    dp[1] = wines[1]
    if n >= 2:
        dp[2] = wines[1] + wines[2]

    for i in range(3, n + 1):
        # 경우 1: i번째 잔을 마시지 않음
        # 경우 2: i번째 잔을 마심 (i-1번째 잔은 안마심)
        # 경우 3: i번째 잔을 마심 (i-1번째 잔도 마심, i-2번째 잔은 안마심)
        dp[i] = max(dp[i-1],                                 # i번째 안마심
                    wines[i] + dp[i-2],                      # i번째 마심, i-1 안마심
                    wines[i] + wines[i-1] + dp[i-3])         # i번째 마심, i-1 마심, i-2 안마심
    print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 `i`번째 포도주 잔까지 고려했을 때 마실 수 있는 포도주의 최대 양을 의미합니다.
`i`번째 포도주 잔에 대한 결정은 다음 세 가지 경우로 나눌 수 있습니다:
1.  **`i`번째 잔을 마시지 않는 경우**: `dp[i-1]` (이전까지의 최댓값과 동일)
2.  **`i`번째 잔을 마시고, `i-1`번째 잔은 마시지 않는 경우** (즉, `... O X O` 패턴): `wines[i] + dp[i-2]`
3.  **`i`번째 잔을 마시고, `i-1`번째 잔도 마시는 경우** (즉, `... O X O O` 패턴, 따라서 `i-2`번째는 마시지 않음): `wines[i] + wines[i-1] + dp[i-3]`

`dp[i]`는 위 세 가지 경우 중 최댓값으로 결정됩니다.
기저 사례:
- `dp[0] = 0` (포도주가 0개면 0) - 코드에서는 1-인덱싱 사용
- `dp[1] = wines[1]` (첫 번째 잔은 무조건 마시는 것이 이득)
- `dp[2] = wines[1] + wines[2]` (두 번째 잔까지는 둘 다 마시는 것이 이득)
`n=0` 또는 `n=1`일 때는 예외 처리를 해줍니다.

---

### ✅ 문제 25. 평범한 배낭 (0/1 Knapsack 복습)

**설명**
N개의 물건이 있고, 각 물건은 무게 `W_i`와 가치 `V_i`를 가집니다. 최대 K만큼의 무게를 담을 수 있는 배낭에 물건들을 담아 가치의 합이 최대가 되도록 하려고 합니다. 각 물건은 하나씩만 있습니다.
첫 줄에는 물건의 수 N (1 <= N <= 100)과 배낭의 최대 무게 K (1 <= K <= 100,000)가 주어집니다. 다음 N개의 줄에는 각 물건의 무게 `W_i`와 가치 `V_i`가 주어집니다 (1 <= W_i, V_i <= 1,000).

**입력 예시**
```
4 7
6 13
4 8
3 6
5 12
```

**출력 예시**
```
14
```

**풀이 코드**
```python
n, k = map(int, input().split())
items = []
for _ in range(n):
    items.append(list(map(int, input().split()))) # [무게, 가치]

# dp[j]는 무게 한도가 j일 때의 최대 가치
dp = [0] * (k + 1)

for weight, value in items:
    # 현재 물건을 고려할 때, 배낭의 용량을 뒤에서부터 확인
    for j in range(k, weight - 1, -1): # j >= weight 여야 함
        dp[j] = max(dp[j], dp[j - weight] + value)

print(dp[k])
```

**풀이에 대한 설명**
이 문제는 전형적인 0/1 배낭 문제입니다 (문제 10 복습). `dp[j]`는 배낭의 용량 한도가 `j`일 때 담을 수 있는 물건들의 최대 가치 합을 저장합니다.
각 물건 `(weight, value)`에 대해, 배낭 용량 `j`를 `k` (최대 용량)부터 `weight` (현재 물건의 무게)까지 역순으로 순회합니다.
역순으로 순회하는 이유는 각 물건을 최대 한 번만 사용하기 위함입니다.
`dp[j]`는 다음 두 값 중 더 큰 값으로 갱신됩니다:
1.  `dp[j]` (현재 물건을 담지 않았을 때, 이전 물건들만으로 용량 `j`를 채웠을 때의 최대 가치)
2.  `dp[j - weight] + value` (현재 물건을 담았을 때의 가치. 즉, 현재 물건의 무게 `weight`를 제외한 용량 `j-weight`에서의 최대 가치에 현재 물건의 가치 `value`를 더한 값)
최종적으로 `dp[k]`가 배낭 용량 K에서의 최대 가치가 됩니다.

---

### ✅ 문제 26. 합분해

**설명**
정수 N을 K개의 0 이상의 정수의 합으로 나타내는 경우의 수를 구하는 문제입니다. 합의 순서가 다르면 다른 경우로 간주합니다. (예: N=2, K=2일 때 0+2, 1+1, 2+0은 서로 다른 경우)
첫 줄에 N과 K가 주어집니다 (1 <= N <= 200, 1 <= K <= 200). 경우의 수는 1,000,000,000으로 나눈 나머지를 출력합니다.

**입력 예시**
```
20 2
```

**출력 예시**
```
21
```

**풀이 코드**
```python
n, k = map(int, input().split())
MOD = 1_000_000_000

# dp[i][j]는 i개의 0 이상의 정수를 더해서 합이 j가 되는 경우의 수
dp = [[0] * (n + 1) for _ in range(k + 1)]

# 초기값 설정: 0을 만드는 경우는 항상 1가지 (0만 사용하는 경우)
for i in range(k + 1):
    dp[i][0] = 1

# 1개의 정수로 j를 만드는 경우는 1가지 (j 자신)
for j in range(n + 1):
    dp[1][j] = 1
    
# dp[i][j] = dp[i-1][j] (마지막 수가 0인 경우) + dp[i][j-1] (마지막 수가 1 이상인 경우)
# 또는 dp[i][j] = sum(dp[i-1][j-l]) for l from 0 to j

for i in range(2, k + 1): # 사용하는 정수의 개수
    for j in range(1, n + 1): # 만들려는 합
        dp[i][j] = (dp[i-1][j] + dp[i][j-1]) % MOD
        
print(dp[k][n])
```

**풀이에 대한 설명**
`dp[i][j]`는 `i`개의 0 이상의 정수를 사용하여 합 `j`를 만드는 경우의 수를 나타냅니다.
점화식은 `dp[i][j] = dp[i-1][j] + dp[i][j-1]` 입니다.
-   `dp[i-1][j]`: `i`번째로 더해지는 수가 0인 경우. 즉, `i-1`개의 수로 합 `j`를 만드는 경우의 수.
-   `dp[i][j-1]`: `i`번째로 더해지는 수가 1 이상인 경우. `i`개의 수로 합 `j`를 만들 때, 각 수에서 1씩 빼면 `i`개의 수로 합 `j-i`를 만드는 것과 유사하나, 더 간단히는 `i`개의 수로 `j-1`을 만드는 경우에서 마지막 수에 1을 더한 것으로 생각할 수 있습니다 (중복 조합 <span class="math-inline">H\(k,n\) \= C\(k\+n\-1, n\)</span>과 관련).

기저 사례:
-   `dp[i][0] = 1` : 어떤 개수의 정수를 사용하든 합이 0이 되는 경우는 모든 수가 0인 경우 1가지입니다.
-   `dp[1][j] = 1` : 1개의 정수를 사용하여 합 `j`를 만드는 경우는 `j` 자신 하나뿐이므로 1가지입니다.
위의 점화식에 이 기저 사례들을 적용하면 `dp` 테이블을 채울 수 있습니다.
예시) `dp[2][1]` (2개로 1 만들기): `dp[1][1]` (1개로 1만들기: 1) + `dp[2][0]` (2개로 0만들기: 1) = 2. (경우: 0+1, 1+0)
최종 결과는 `dp[k][n]`입니다.

---

### ✅ 문제 27. 가장 긴 팰린드롬 부분 수열 (LPS) - 길이

**설명**
주어진 문자열의 부분 수열(subsequence) 중에서 가장 긴 팰린드롬(palindrome)의 길이를 구하는 문제입니다. 부분 수열은 원래 문자열에서 일부 문자를 삭제하여 만들 수 있으며, 순서는 유지됩니다.
첫 줄에 문자열이 주어집니다. 문자열의 길이는 1 이상 100 이하이며, 알파벳 대문자로만 이루어져 있습니다.

**입력 예시**
```
ABBDCACB
```

**출력 예시**
```
5
```

**풀이 코드**
```python
s = input()
s_rev = s[::-1] # 문자열 뒤집기
n = len(s)

# dp[i][j]는 s의 첫 i글자와 s_rev의 첫 j글자 사이의 LCS 길이
dp = [[0] * (n + 1) for _ in range(n + 1)]

for i in range(1, n + 1):
    for j in range(1, n + 1):
        if s[i-1] == s_rev[j-1]:
            dp[i][j] = dp[i-1][j-1] + 1
        else:
            dp[i][j] = max(dp[i-1][j], dp[i][j-1])

print(dp[n][n])
```

**풀이에 대한 설명**
어떤 문자열의 가장 긴 팰린드롬 부분 수열(LPS)의 길이는, 해당 문자열과 그 문자열을 뒤집은 것 사이의 가장 긴 공통 부분 수열(LCS)의 길이와 같습니다.
예를 들어, "ABBDCACB"의 LPS는 "ABCBA" 또는 "ABDCA"(팰린드롬 아님), "BCACB" 등 다양한 부분 수열이 가능합니다. 팰린드롬인 것은 "ABCBA", "BCACB" (길이 5).
"ABBDCACB" 와 뒤집은 문자열 "BCACDBBA" 의 LCS를 구하면 됩니다.

이 문제는 문제 13 (가장 긴 공통 부분 수열 - 길이)의 로직을 그대로 활용합니다.
1.  원본 문자열 `s`를 준비합니다.
2.  `s`를 뒤집은 문자열 `s_rev`를 만듭니다.
3.  `s`와 `s_rev` 사이의 LCS 길이를 계산합니다.
`dp[i][j]`는 `s`의 처음 `i`개 문자와 `s_rev`의 처음 `j`개 문자 사이의 LCS 길이를 저장합니다.
점화식은 LCS와 동일합니다:
-   `s[i-1] == s_rev[j-1]` 이면, `dp[i][j] = dp[i-1][j-1] + 1`
-   다르면, `dp[i][j] = max(dp[i-1][j], dp[i][j-1])`
최종 결과는 `dp[n][n]`입니다.

---

### ✅ 문제 28. 계단 오르기 (점수 최대화, 연속 3칸 불가)

**설명**
N개의 계단이 있고, 각 계단에는 특정 점수가 있습니다. 계단을 오를 때는 한 번에 한 계단 또는 두 계단을 오를 수 있습니다. 단, 연속된 세 개의 계단을 모두 밟을 수는 없습니다(즉, `i, i-1, i-2`번째 계단을 연달아 밟는 것은 금지). 시작점은 계단이 아니며, 마지막 N번째 계단은 반드시 밟아야 합니다. 얻을 수 있는 점수의 최댓값을 구하세요.
첫 줄에는 계단의 개수 N (1 <= N <= 300)이 주어지고, 둘째 줄부터 N개의 줄에 걸쳐 각 계단의 점수가 주어집니다.

**입력 예시**
```
6
10
20
15
25
10
20
```

**출력 예시**
```
75
```

**풀이 코드**
```python
n = int(input())
scores = [0] * (n + 1) # 1-indexed
for i in range(1, n + 1):
    scores[i] = int(input())

# dp[i]는 i번째 계단을 밟았을 때까지의 최대 점수
dp = [0] * (n + 1)

if n >= 1:
    dp[1] = scores[1]
if n >= 2:
    # dp[2]는 (0->1->2) 또는 (0->2)
    # 0->1->2: scores[1] + scores[2]
    # 0->2: scores[2] (시작점에서 2칸 점프는 scores[1]을 밟지 않음)
    # 이 문제에서 "한 계단 또는 두 계단"이므로 0->2는 scores[2]만.
    # dp[2] = scores[2] + dp[0] (if first step is 2) or scores[2] + scores[1] (if first two steps are 1 then 1)
    # 여기서는 s1 -> s2 또는 s0 -> s2.
    # 연속 3칸 금지 규칙은 3번째 계단부터 의미가 있음.
    dp[2] = scores[1] + scores[2] # 1번째 밟고 2번째 밟기

for i in range(3, n + 1):
    # i번째 계단을 밟는 경우:
    # 1. (i-2)번째 계단을 밟고 -> i번째 계단으로 두 칸 점프 (i-1번째 안 밟음)
    #    점수: dp[i-2] + scores[i]
    # 2. (i-3)번째 계단을 밟고 -> (i-1)번째 계단을 밟고 -> i번째 계단으로 한 칸 점프
    #    (i-2번째 안 밟음, 연속 3칸 방지)
    #    점수: dp[i-3] + scores[i-1] + scores[i]
    dp[i] = max(dp[i-2] + scores[i], dp[i-3] + scores[i-1] + scores[i])

print(dp[n])
```

**풀이에 대한 설명**
`dp[i]`는 `i`번째 계단을 (반드시) 밟았을 때, 시작점부터 `i`번째 계단까지 도달하면서 얻을 수 있는 최대 점수를 의미합니다. 마지막 계단은 반드시 밟아야 합니다.
-   기저 사례:
    -   `dp[0] = 0` (시작점)
    -   `dp[1] = scores[1]` (첫 번째 계단을 밟는 경우)
    -   `dp[2] = scores[1] + scores[2]` (첫 번째와 두 번째 계단을 모두 밟는 경우. 두 번째 계단만 밟는 경우는 `scores[2]`인데, `scores[1]+scores[2]`가 일반적으로 더 크거나 같으므로, 이 문제에서는 `dp[2]`를 이렇게 설정하는 것이 일반적입니다. 또는 `scores[2] + max(scores[1], dp[0])`도 가능.) 여기서는 연속된 계단을 밟는 것을 우선시하여 `scores[1]+scores[2]`로 설정합니다. 문제 조건에 따라 `dp[2] = max(scores[2], scores[1]+scores[2])`가 될 수도 있습니다. 하지만 일반적으로 `scores[1]`은 양수이므로 `scores[1]+scores[2]`가 최대입니다.

-   점화식 (`i >= 3`):
    `i`번째 계단을 밟는 방법은 두 가지가 있습니다:
    1.  `i-2`번째 계단에서 두 칸을 뛰어 `i`번째 계단을 밟는 경우: 이때의 점수는 `dp[i-2] + scores[i]`.
        (이 경우 `i-1`번째 계단을 밟지 않으므로 연속 3칸 규칙에 위배되지 않음)
    2.  `i-1`번째 계단을 밟고 `i`번째 계단을 밟는 경우: 이 경우 `i-2`번째 계단은 밟지 않아야 연속 3칸 규칙을 만족합니다. 따라서 `i-3`번째 계단을 밟고 -> `i-1`번째 계단 -> `i`번째 계단 순으로 온 것입니다.
        이때의 점수는 `dp[i-3] + scores[i-1] + scores[i]`.
    `dp[i] = max(dp[i-2] + scores[i], dp[i-3] + scores[i-1] + scores[i])`
최종 답은 `dp[n]`입니다.

---

### ✅ 문제 29. 이친수 (Pinary Number)

**설명**
이친수(Pinary Number)는 다음 두 가지 조건을 만족하는 이진수입니다.
1.  0으로 시작하지 않는다.
2.  1이 두 번 연속으로 나타나지 않는다. (예: 11은 이친수가 아님)
N이 주어졌을 때, N자리 이친수의 개수를 구하는 프로그램을 작성하세요. N은 1 이상 90 이하입니다.

**입력 예시**
```
3
```

**출력 예시**
```
2
```

**풀이 코드**
```python
n = int(input())

# dp[i][0]: i자리 이친수 중 0으로 끝나는 것의 개수
# dp[i][1]: i자리 이친수 중 1으로 끝나는 것의 개수
dp = [[0] * 2 for _ in range(n + 1)]

# 1자리 이친수는 '1' 하나뿐 (0으로 시작 불가)
if n >= 1:
    dp[1][0] = 0 
    dp[1][1] = 1

for i in range(2, n + 1):
    # i자리 이친수가 0으로 끝나는 경우:
    # (i-1)자리 이친수가 0으로 끝나거나 1로 끝나는 경우 모두 뒤에 0을 붙일 수 있음
    dp[i][0] = dp[i-1][0] + dp[i-1][1]
    
    # i자리 이친수가 1로 끝나는 경우:
    # (i-1)자리 이친수가 0으로 끝나야만 뒤에 1을 붙일 수 있음 (11 방지)
    dp[i][1] = dp[i-1][0]

print(dp[n][0] + dp[n][1])
```

**풀이에 대한 설명**
`dp[i][j]`는 길이가 `i`인 이친수 중에서 `j`로 끝나는 것의 개수를 의미합니다 (`j=0` 또는 `j=1`).
-   기저 사례: `dp[1][0] = 0` (1자리 이친수는 "1"뿐이므로 0으로 끝날 수 없음), `dp[1][1] = 1` (이친수 "1").
-   점화식 (`i >= 2`):
    -   `dp[i][0]` (길이 `i`, 0으로 끝남):
        길이가 `i-1`인 이친수가 0으로 끝나든 1로 끝나든 그 뒤에 0을 붙일 수 있습니다.
        따라서 `dp[i][0] = dp[i-1][0] + dp[i-1][1]`.
    -   `dp[i][1]` (길이 `i`, 1으로 끝남):
        1이 연속으로 나올 수 없으므로, 길이가 `i-1`인 이친수는 반드시 0으로 끝나야 합니다.
        따라서 `dp[i][1] = dp[i-1][0]`.
N자리 이친수의 총 개수는 `dp[n][0] + dp[n][1]`입니다. 이 값은 피보나치 수열과 같습니다 (`F[N]`, 단 `F[1]=1, F[2]=1`인 수열).

---

### ✅ 문제 30. 쉬운 경로 찾기 (2D Grid)

**설명**
R x C 크기의 격자가 주어집니다. 가장 왼쪽 위 칸 (0,0)에서 가장 오른쪽 아래 칸 (R-1, C-1)까지 이동하려고 합니다. 이동은 오직 오른쪽 또는 아래쪽으로만 가능합니다. (0,0)에서 (R-1, C-1)까지 가는 경로의 총 개수를 구하는 프로그램을 작성하세요. (장애물은 없음)
첫 줄에는 R과 C가 주어집니다 (1 <= R, C <= 15).

**입력 예시**
```
3 4
```

**출력 예시**
```
10
```

**풀이 코드**
```python
r, c = map(int, input().split())

# dp[i][j]는 (0,0)에서 (i,j)까지 가는 경로의 수
dp = [[0] * c for _ in range(r)]

# 초기값 설정: 첫 행과 첫 열은 경로가 1가지뿐
for i in range(r):
    dp[i][0] = 1
for j in range(c):
    dp[0][j] = 1

# (0,0)은 중복 계산될 수 있으나, dp[0][0]=1로 덮어쓰여짐.

for i in range(1, r):
    for j in range(1, c):
        # (i,j)로 오는 방법은 (i-1,j)에서 아래로 오거나, (i,j-1)에서 오른쪽으로 오는 경우
        dp[i][j] = dp[i-1][j] + dp[i][j-1]

print(dp[r-1][c-1])
```

**풀이에 대한 설명**
`dp[i][j]`는 시작점 (0,0)에서 격자 내의 (i,j) 위치까지 도달하는 경로의 총 개수를 저장합니다.
이동은 오른쪽 또는 아래로만 가능합니다.
-   기저 사례:
    -   첫 번째 행의 모든 칸(`dp[0][j]`)까지 가는 방법은 오직 오른쪽으로만 계속 이동하는 1가지입니다.
    -   첫 번째 열의 모든 칸(`dp[i][0]`)까지 가는 방법은 오직 아래쪽으로만 계속 이동하는 1가지입니다.
    -   따라서 `dp[i][0] = 1` for all `i`, and `dp[0][j] = 1` for all `j`. (결과적으로 `dp[0][0]=1`이 됩니다).
-   점화식 (`i > 0` and `j > 0`):
    `(i,j)` 위치에 도달하기 위해서는 두 가지 방법이 있습니다:
    1.  `(i-1, j)` 위치에서 아래로 이동하는 경우.
    2.  `(i, j-1)` 위치에서 오른쪽으로 이동하는 경우.
    따라서 `dp[i][j] = dp[i-1][j] + dp[i][j-1]`.
최종 결과는 `dp[r-1][c-1]` (가장 오른쪽 아래 칸)에 저장된 값입니다. 이는 조합 <span class="math-inline">C\(R\+C\-2, R\-1\)</span> 또는 <span class="math-inline">C\(R\+C\-2, C\-1\)</span>과 같습니다.

