# 🏋️‍♂️ set(집합) 문법 드릴 문제집

Python `set` 연산을 반복 숙달하기 위한 문제집입니다.
각 문제는 입력·출력 형식이 짧고 명확하며, 핵심 개념 사용에 집중합니다.

---

## ✅ 문제 1. 합집합 크기 계산

**설명** 두 집합 A와 B가 주어집니다.  
첫 줄에는 각 집합의 원소 개수 n, m이 주어집니다.  
둘째 줄에는 A의 원소, 셋째 줄에는 B의 원소가 공백으로 주어집니다.  
A ∪ B의 원소 개수를 출력해야 합니다.

**입력 예시**
```
3 4
1 2 3
2 3 4 5
```

**출력 예시**
```
5
```

**풀이 코드**
```python
n, m = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
print(len(a | b))
```

**풀이에 대한 설명**
- `map(int, input().split())`은 공백으로 구분된 문자열 입력을 받아 각 문자를 정수로 변환합니다.
- `set()` 함수는 이 정수들로 집합을 생성합니다.
- `|` 연산자는 두 집합의 합집합(union)을 계산합니다.
- `len()` 함수는 합집합의 원소 개수를 반환합니다.

---

## ✅ 문제 2. 중복 제거 후 오름차순 출력

**설명** 정수 리스트가 주어집니다.  
첫 줄에는 원소 개수 n이 주어지고, 둘째 줄에는 n개의 정수가 공백으로 주어집니다.  
중복을 제거한 뒤 오름차순으로 출력해야 합니다.

**입력 예시**
```
8
5 3 5 2 2 1 4 3
```

**출력 예시**
```
1 2 3 4 5
```

**풀이 코드**
```python
input()            # 첫 줄은 무시
nums = set(map(int, input().split()))
print(*sorted(nums))
```

**풀이에 대한 설명**
- 첫 번째 `input()`은 원소의 개수를 나타내는 첫 줄을 읽고 무시합니다.
- `set(map(int, input().split()))`은 입력받은 정수 리스트에서 중복을 자동으로 제거하여 집합을 만듭니다.
- `sorted(nums)`는 집합 `nums`의 원소들을 오름차순으로 정렬한 새로운 리스트를 반환합니다.
- `*` 연산자(언패킹)는 리스트의 각 원소를 개별 인자로 `print` 함수에 전달하여 공백으로 구분해 출력합니다.

---

## ✅ 문제 3. 차집합 원소 출력

**설명** 집합 A, B가 주어집니다.  
A − B(집합 차집합)의 원소를 오름차순으로 출력해야 합니다.  
없으면 `None`을 출력합니다.

**입력 예시**
```
5 3
1 2 3 4 5
3 4 6
```

**출력 예시**
```
1 2 5
```

**풀이 코드**
```python
n, m = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
diff = sorted(a - b)
print(*diff if diff else ["None"])
```

**풀이에 대한 설명**
- `-` 연산자는 집합 `a`에서 집합 `b`의 원소를 제외한 차집합(difference)을 계산합니다.
- `sorted()` 함수는 차집합의 결과를 오름차순으로 정렬합니다.
- `print(*diff if diff else ["None"])`는 `diff` 리스트가 비어있지 않으면 원소들을 언패킹하여 출력하고, 비어있으면 `["None"]` 리스트를 언패킹하여 "None"을 출력합니다.

---

## ✅ 문제 4. 대칭 차집합 크기

**설명** 두 집합 A, B가 주어집니다.  
A △ B(대칭 차집합, 합집합 − 교집합)의 원소 개수를 출력해야 합니다.

**입력 예시**
```
4 5
1 2 3 4
3 4 5 6 7
```

**출력 예시**
```
5
```

**풀이 코드**
```python
n, m = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
print(len(a ^ b))
```

**풀이에 대한 설명**
- `^` 연산자는 두 집합의 대칭 차집합(symmetric difference)을 계산합니다. 대칭 차집합은 두 집합 중 어느 한쪽에만 속하는 원소들의 집합입니다.
- `len()` 함수는 대칭 차집합의 원소 개수를 반환합니다.

---

## ✅ 문제 5. 부분집합 판별

**설명** 두 집합 A, B가 주어집니다.  
A가 B의 부분집합이면 YES, 아니면 NO를 출력해야 합니다.

**입력 예시**
```
3 5
1 2 3
0 1 2 3 4
```

**출력 예시**
```
YES
```

**풀이 코드**
```python
n, m = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
print("YES" if a <= b else "NO")
```

**풀이에 대한 설명**
- `<=` 연산자는 첫 번째 집합이 두 번째 집합의 부분집합(subset)인지 판별합니다. `a.issubset(b)`와 동일한 기능을 합니다.
- 조건 표현식 `("YES" if a <= b else "NO")`을 사용하여 판별 결과에 따라 "YES" 또는 "NO"를 출력합니다.

---

## ✅ 문제 6. 공통 원소 존재 여부

**설명** 두 문자열이 주어집니다.  
두 문자열에 공통 문자가 하나라도 있으면 1, 없으면 0을 출력해야 합니다.  
대소문자를 구분하지 않습니다.

**입력 예시**
```
hello
world
```

**출력 예시**
```
1
```

**풀이 코드**
```python
a = set(input().lower())
b = set(input().lower())
print(1 if a & b else 0)
```

**풀이에 대한 설명**
- `input().lower()`는 입력받은 문자열을 모두 소문자로 변환합니다.
- `set()` 함수는 문자열을 문자 단위로 쪼개 집합으로 만듭니다.
- `&` 연산자는 두 집합의 교집합(intersection)을 계산합니다.
- `if a & b`는 교집합이 비어있지 않으면 (즉, 공통 문자가 존재하면) 참으로 평가됩니다.

---

## ✅ 문제 7. 고유 단어 개수 세기

**설명** 한 줄에 단어들이 공백으로 주어집니다.  
대소문자를 구분하지 않고 고유 단어 개수를 출력해야 합니다.

**입력 예시**
```
Apple banana apple Orange BANANA
```

**출력 예시**
```
3
```

**풀이 코드**
```python
words = input().lower().split()
print(len(set(words)))
```

**풀이에 대한 설명**
- `input().lower().split()`는 입력받은 한 줄의 문자열을 소문자로 변환한 후, 공백을 기준으로 나누어 단어 리스트를 생성합니다.
- `set(words)`는 단어 리스트를 집합으로 변환하여 자동으로 중복된 단어를 제거합니다.
- `len()` 함수는 고유한 단어들의 집합의 크기, 즉 고유 단어의 개수를 반환합니다.

---

## ✅ 문제 8. 세 집합 교집합 크기

**설명** 세 집합 A, B, C가 주어집니다.  
첫 줄에는 각 집합의 원소 개수 n, m, k가 주어집니다.  
뒤이어 세 줄에 각 집합의 원소가 공백으로 주어집니다.  
A ∩ B ∩ C의 원소 개수를 출력해야 합니다.

**입력 예시**
```
3 4 5
1 2 3
2 3 4 5
0 2 3 5 6
```

**출력 예시**
```
1
```

**풀이 코드**
```python
n, m, k = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
c = set(map(int, input().split()))
print(len(a & b & c))
```

**풀이에 대한 설명**
- `&` 연산자는 집합 간의 교집합을 계산합니다.
- `a & b & c`는 세 집합 `a`, `b`, `c` 모두에 공통으로 존재하는 원소들의 집합을 반환합니다.
- `len()` 함수는 이 교집합의 원소 개수를 반환합니다.

---

## ✅ 문제 9. 중복 제거하며 입력 순서 유지

**설명** 정수 n과 이어서 n개의 정수가 공백으로 주어집니다.  
중복을 제거하되, **첫 등장 순서**를 유지해 출력해야 합니다.

**입력 예시**
```
9
5 1 5 2 3 2 4 1 5
```

**출력 예시**
```
5 1 2 3 4
```

**풀이 코드**
```python
input()                     # 첫 줄은 무시
nums = input().split()
seen = set()
res = []
for x in nums:
    if x not in seen:
        seen.add(x)
        res.append(x)
print(*res)
```

**풀이에 대한 설명**
- 첫 번째 `input()`은 원소의 개수 n을 읽고 무시합니다.
- 입력된 숫자 문자열들을 `nums` 리스트에 저장합니다.
- `seen` 집합은 이미 등장한 원소를 기록하는 데 사용됩니다.
- `res` 리스트에는 중복이 제거되고 첫 등장 순서가 유지된 원소들이 저장됩니다.
- `for` 루프를 통해 `nums`의 각 원소 `x`를 순회하며, `x`가 `seen`에 없으면 (`x not in seen`), `x`를 `seen`에 추가하고 `res` 리스트에도 추가합니다.
- 마지막으로 `*res`를 사용하여 `res` 리스트의 원소들을 공백으로 구분하여 출력합니다.

---

## ✅ 문제 10. 모든 원소 포함 여부

**설명** 집합 A와 정수 리스트 L이 주어집니다.  
L의 모든 원소가 A에 포함되면 TRUE, 아니면 FALSE를 출력해야 합니다.

**입력 예시**
```
5
1 2 3 4 5
3
2 4 5
```

**출력 예시**
```
TRUE
```

**풀이 코드**
```python
n = int(input())
a = set(map(int, input().split()))
m = int(input())
l = list(map(int, input().split()))
print("TRUE" if set(l) <= a else "FALSE")
```

**풀이에 대한 설명**
- 집합 `a`와 리스트 `l`을 입력받습니다.
- `set(l)`은 리스트 `l`을 집합으로 변환합니다.
- `set(l) <= a`는 `set(l)`이 집합 `a`의 부분집합인지 확인하는 연산입니다. 즉, 리스트 `l`의 모든 원소가 집합 `a`에 포함되어 있는지 검사합니다.
- 결과에 따라 "TRUE" 또는 "FALSE"를 출력합니다.

---

## ✅ 문제 11. 두 집합 동일 여부

**설명** 두 집합 A, B가 주어집니다.  
첫 줄에는 각 집합의 원소 개수 n, m이 주어집니다.  
둘째 줄에는 A의 원소, 셋째 줄에는 B의 원소가 공백으로 주어집니다.  
A와 B가 완전히 같으면 `EQUAL`, 다르면 `UNEQUAL`을 출력해야 합니다.

**입력 예시**
```
3 3
1 2 3
3 1 2
```

**출력 예시**
```
EQUAL
```

**풀이 코드**
```python
n, m = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
print("EQUAL" if a == b else "UNEQUAL")
```

**풀이에 대한 설명**
- `==` 연산자는 두 집합이 동일한 원소를 가지고 있는지 비교합니다. 집합에서 원소의 순서는 고려되지 않으므로, 원소 구성만 같다면 두 집합은 동일한 것으로 간주됩니다.
- 조건 표현식을 사용하여 두 집합이 같으면 "EQUAL", 다르면 "UNEQUAL"을 출력합니다.

---

## ✅ 문제 12. 대칭 차집합 원소 출력

**설명** 두 집합 A, B가 주어집니다.  
A △ B(대칭 차집합)의 원소를 오름차순으로 출력해야 합니다.  
대칭 차집합이 비면 `None`을 출력합니다.

**입력 예시**
```
4 5
1 2 3 4
3 4 5 6 7
```

**출력 예시**
```
1 2 5 6 7
```

**풀이 코드**
```python
n, m = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
sym = sorted(a ^ b)
print(*sym if sym else ["None"])
```

**풀이에 대한 설명**
- `^` 연산자는 두 집합의 대칭 차집합(symmetric difference)을 계산합니다.
- `sorted()` 함수는 대칭 차집합의 결과를 오름차순으로 정렬합니다.
- `print(*sym if sym else ["None"])`는 `sym` 리스트가 비어있지 않으면 원소들을 언패킹하여 출력하고, 비어있으면 `["None"]` 리스트를 언패킹하여 "None"을 출력합니다.

---

## ✅ 문제 13. 두 문자열의 고유 알파벳 수

**설명** 두 문자열 s₁, s₂가 주어집니다.  
대소문자를 구분하지 않고, 공백을 제외한 고유 알파벳 개수를 출력해야 합니다.

**입력 예시**
```
Hello
World
```

**출력 예시**
```
7
```

**풀이 코드**
```python
a = set(input().lower()) - {" "}
b = set(input().lower()) - {" "}
print(len(a | b))
```

**풀이에 대한 설명**
- `input().lower()`로 각 문자열을 입력받아 소문자로 변환합니다.
- `set()`으로 문자열을 문자 집합으로 만듭니다.
- `- {" "}` 연산을 통해 각 집합에서 공백 문자를 제거합니다.
- `|` 연산자로 두 문자 집합의 합집합을 구하여 두 문자열에 등장하는 모든 고유 알파벳(공백 제외)을 얻습니다.
- `len()`으로 합집합의 크기, 즉 고유 알파벳의 개수를 출력합니다.

---

## ✅ 문제 14. 1 ~ N 중 누락된 숫자

**설명** 양의 정수 N이 주어지고, 이어서 N − 1개의 정수가 한 줄에 주어집니다.  
1 ~ N 사이에서 **누락된 숫자**를 오름차순으로 출력해야 합니다.  
누락된 숫자가 없으면 `None`을 출력합니다.

**입력 예시**
```
5
2 3 1 5
```

**출력 예시**
```
4
```

**풀이 코드**
```python
n = int(input())
given = set(map(int, input().split()))
missing = sorted(set(range(1, n + 1)) - given)
print(*missing if missing else ["None"])
```

**풀이에 대한 설명**
- `set(range(1, n + 1))`은 1부터 N까지의 모든 정수를 포함하는 집합을 생성합니다.
- `given`은 입력으로 주어진 N-1개의 정수들로 이루어진 집합입니다.
- `set(range(1, n + 1)) - given`은 1부터 N까지의 숫자 중 `given` 집합에 없는 숫자, 즉 누락된 숫자들의 집합을 계산합니다.
- `sorted()`로 누락된 숫자들을 오름차순으로 정렬합니다.
- 결과 리스트 `missing`이 비어있으면 "None"을, 그렇지 않으면 누락된 숫자들을 출력합니다.

---

## ✅ 문제 15. 다중 원소 포함 검사

**설명** 집합 A와 질의 Q개가 주어집니다.  
각 질의로 정수 x가 주어질 때, x가 A에 포함되면 1, 아니면 0을 순서대로 한 줄에 공백으로 출력해야 합니다.

**입력 예시**
```
5
10 20 30 40 50
4
30
25
10
60
```

**출력 예시**
```
1 0 1 0
```

**풀이 코드**
```python
n = int(input())
a = set(map(int, input().split()))
q = int(input())
res = []
for _ in range(q):
    x = int(input())
    res.append("1" if x in a else "0")
print(" ".join(res))
```

**풀이에 대한 설명**
- 초기 집합 `a`를 입력받아 생성합니다.
- 질의의 개수 `q`를 입력받습니다.
- `for` 루프를 `q`번 반복하면서 각 질의 정수 `x`를 입력받습니다.
- `x in a` 표현식은 `x`가 집합 `a`에 포함되어 있는지 확인하여 `True` 또는 `False`를 반환합니다. 이는 집합에서 매우 효율적인 연산입니다.
- 조건 표현식을 사용하여 `x`가 `a`에 있으면 "1", 없으면 "0"을 `res` 리스트에 추가합니다.
- 모든 질의 처리 후, `res` 리스트의 문자열들을 공백으로 연결하여 한 줄로 출력합니다.

---

## ✅ 문제 16. 서로소(disjoint) 여부

**설명** 두 집합 A, B가 주어집니다.  
A와 B가 서로소면 `DISJOINT`, 아니면 `OVERLAP`을 출력해야 합니다.

**입력 예시**
```
3 3
1 2 3
4 5 6
```

**출력 예시**
```
DISJOINT
```

**풀이 코드**
```python
n, m = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
print("DISJOINT" if a.isdisjoint(b) else "OVERLAP")
```

**풀이에 대한 설명**
- `a.isdisjoint(b)` 메소드는 집합 `a`와 집합 `b`가 서로소인지, 즉 공통 원소를 하나도 가지지 않는지 확인합니다. 공통 원소가 없으면 `True`를, 있으면 `False`를 반환합니다.
- 조건 표현식을 사용하여 메소드의 반환 값에 따라 "DISJOINT" 또는 "OVERLAP"을 출력합니다.

---

## ✅ 문제 17. 마지막 등장 순서 유지 중복 제거

**설명** 정수 n과 이어서 n개의 정수가 공백으로 주어집니다.  
같은 숫자가 여러 번 나오면 **가장 마지막에 등장한 것만** 남기고, 그 순서를 유지해 출력해야 합니다.

**입력 예시**
```
9
5 1 5 2 3 2 4 1 5
```

**출력 예시**
```
5 2 3 4 1
```

**풀이 코드**
```python
input()                     # 첫 줄은 무시
nums = input().split()
seen = set()
res = []
for x in reversed(nums):
    if x not in seen:
        seen.add(x)
        res.append(x)
print(*reversed(res))
```

**풀이에 대한 설명**
- 첫 번째 `input()`은 원소의 개수 n을 읽고 무시합니다.
- `reversed(nums)`를 사용하여 입력된 숫자 문자열 리스트를 역순으로 순회합니다.
- `seen` 집합은 이미 처리된 (즉, 마지막 등장으로 간주된) 원소를 기록합니다.
- `res` 리스트에는 결과가 역순으로 (원래 순서 기준으로는 마지막 등장부터 첫 등장 순으로) 저장됩니다.
- 역순 순회 중 원소 `x`가 `seen`에 없으면, 이는 `x`의 (원래 리스트에서의) 마지막 등장이므로 `seen`에 추가하고 `res`에도 추가합니다.
- 최종적으로 `reversed(res)`를 통해 `res` 리스트를 다시 역순으로 만들어 원래의 마지막 등장 순서를 맞춘 후 언패킹하여 출력합니다.

---

## ✅ 문제 18. 고유 홀수 제곱값 출력

**설명** 첫 줄에 정수 n이 주어집니다.  
둘째 줄에는 n개의 정수가 공백으로 주어집니다.  
홀수인 값의 **제곱**을 구해 중복 없이 오름차순으로 출력해야 합니다.

**입력 예시**
```
10
1 2 3 4 5 6 7 8 9 10
```

**출력 예시**
```
1 9 25 49 81
```

**풀이 코드**
```python
input()  # 첫 줄은 무시
nums = set(map(int, input().split()))
odd_squares = sorted({x * x for x in nums if x % 2})
print(*odd_squares)
```

**풀이에 대한 설명**
- 첫 번째 `input()`은 정수 n을 읽고 무시합니다.
- `nums = set(map(int, input().split()))`는 입력된 정수들을 받아 집합으로 만들어 초기에 중복을 제거합니다.
- `{x * x for x in nums if x % 2}`는 집합 내포(set comprehension) 구문입니다.
    - `for x in nums`: `nums` 집합의 각 원소 `x`에 대해 반복합니다.
    - `if x % 2`: `x`가 홀수인지 확인합니다 (`x % 2`의 결과가 0이 아니면 홀수).
    - `x * x`: 홀수인 `x`의 제곱을 계산합니다.
    - 이 결과들이 새로운 집합에 저장되므로, 제곱 값들 중 중복된 값은 자동으로 제거됩니다.
- `sorted()` 함수가 이 고유한 홀수 제곱값들의 집합을 오름차순으로 정렬된 리스트로 변환합니다.
- `*` 연산자로 리스트를 언패킹하여 출력합니다.

---

## ✅ 문제 19. 집합 갱신 후 최종 상태

**설명** 초기 집합과 연산 k개가 주어집니다.  
연산은 `add x`, `remove x`, `discard x` 형태입니다.  
모든 연산을 수행한 뒤 집합 원소를 오름차순으로 출력해야 합니다.

**입력 예시**
```
4
1 2 3 4
4
add 5
remove 2
discard 10
add 1
```

**출력 예시**
```
1 3 4 5
```

**풀이 코드**
```python
n = int(input())
s = set(map(int, input().split()))
k = int(input())
for _ in range(k):
    cmd, x_str = input().split()
    x = int(x_str)
    if cmd == "add":
        s.add(x)
    elif cmd == "remove":
        s.remove(x)      # 반드시 존재한다고 가정
    else:                # discard
        s.discard(x)
print(*sorted(s))
```

**풀이에 대한 설명**
- 초기 집합 `s`를 입력받아 생성합니다.
- 연산의 개수 `k`를 입력받습니다.
- `for` 루프를 `k`번 반복하면서 각 연산을 처리합니다.
    - `input().split()`으로 명령어(`cmd`)와 값(`x_str`)을 분리하고, `x`를 정수로 변환합니다.
    - `s.add(x)`: 집합 `s`에 원소 `x`를 추가합니다. 이미 존재하면 변화가 없습니다.
    - `s.remove(x)`: 집합 `s`에서 원소 `x`를 제거합니다. `x`가 집합에 없으면 `KeyError`가 발생합니다 (문제에서는 존재한다고 가정).
    - `s.discard(x)`: 집합 `s`에서 원소 `x`를 제거합니다. `x`가 집합에 없어도 오류가 발생하지 않습니다.
- 모든 연산이 끝난 후, `sorted(s)`를 통해 집합 `s`의 원소들을 오름차순으로 정렬하고, `*` 연산자로 언패킹하여 출력합니다.

---

## ✅ 문제 20. 최소 두 집합에 포함된 원소

**설명** 세 집합 A, B, C가 주어집니다.  
A, B, C 중 **적어도 두 집합**에 포함된 원소를 오름차순으로 출력해야 합니다.  
없으면 `None`을 출력합니다.

**입력 예시**
```
3 3 4
1 2 3
2 3 4
3 4 5 6
```

**출력 예시**
```
2 3 4
```

**풀이 코드**
```python
n, m, k = map(int, input().split())
a = set(map(int, input().split()))
b = set(map(int, input().split()))
c = set(map(int, input().split()))
result = sorted((a & b) | (b & c) | (a & c))
print(*result if result else ["None"])
```

**풀이에 대한 설명**
- 세 집합 `a`, `b`, `c`를 입력받아 생성합니다.
- "적어도 두 집합에 포함된 원소"는 다음 세 가지 교집합의 합집합으로 구할 수 있습니다:
    - `a & b`: A와 B 모두에 포함된 원소
    - `b & c`: B와 C 모두에 포함된 원소
    - `a & c`: A와 C 모두에 포함된 원소
- `(a & b) | (b & c) | (a & c)`는 이 세 교집합들의 합집합을 계산하여, A, B, C 중 적어도 두 곳에 속하는 모든 고유한 원소들을 모읍니다.
- `sorted()` 함수는 이 결과 집합을 오름차순으로 정렬된 리스트로 변환합니다.
- `print(*result if result else ["None"])`는 결과 리스트 `result`가 비어있지 않으면 원소들을 언패킹하여 출력하고, 비어있으면 `["None"]` 리스트를 언패킹하여 "None"을 출력합니다.

